# TEMA 2.4 - PROGRAMACIÓN A NIVEL-MÁQUINA IV: DATOS

## §2.4.1 - Arrays

### Ubicación de arrays

Un array definido como `T array[L]` para un tipo de dato `T` y una longitud `L` ocupa en memoria una región contigua de `L * sizeof(T)` bytes.

| Declaración      | Tamaño (bytes) | Posiciones          |
| :--------------- | :------------: | :------------------ |
| `char cad[12]`   |      $12$      | $x,x+1,\cdots,x+12$ |
| `int num[5]`     |      $20$      | $x,x+4,\cdots,x+20$ |
| `double d[3]`    |      $24$      | $x,x+8,\cdots,x+24$ |
| `char* lista[3]` |      $24$      | $x,x+8,\cdots,x+24$ |

Podemos crear arrays definiendo un tipo de dato:

```c
#define LONGITUD 5
typedef int mi_array[LONGITUD];

mi_array arr1 = {1, 2, 3, 4, 5};
mi_array arr2 = {5, 4, 3, 2, 1};
```

La declaración secuencial de arrays **puede** que haga que éstos se almacenen de forma contigua en memoria, pero **nunca** se garantiza que éste sea el caso.

### Acceso a arrays

Tengamos el siguiente array:

```c
int val[5] = {1, 5, 2, 1, 3};
```

\pagebreak

Podemos referenciarlo (`int*`) o desreferenciarlo (`int`) con las siguientes expresiones:

| Expresión  | Tipo devuelto |
| :--------- | :------------ |
| `val[4]`   | `int`         |
| `*(val+1)` | `int`         |
| `val`      | `int*`        |
| `val+1`    | `int*`        |
| `val+i`    | `int*`        |
| `&val[2]`  | `int*`        |

Tengamos la siguiente rutina en C que devuelve un elemento de un array:

```c
int extraer_val (int* a, size_t pos) {
	return a[pos];
}
```

La traducimos así a lenguaje ensamblador:

```asm
extraer_val:
	movl (%rdi, %rsi, 4), %eax
	ret
```

Accedemos a la posición definida como `%rdi + %rsi` (dirección de inicio e índice respectivamente) multiplicada por $4$ bytes, el tamaño de `int`.

De la misma forma, podemos modificar el contenido de los arrays en bucle.
Por ejemplo, tengamos el siguiente bucle en C:

```c
void bucle (int* a, size_t tam) {
	for (size_t i=0; i<tam; i++)
		a[i]++;
}
```

# TODO



## §2.4.2 - Estructuras

## §2.4.3 - Uniones

