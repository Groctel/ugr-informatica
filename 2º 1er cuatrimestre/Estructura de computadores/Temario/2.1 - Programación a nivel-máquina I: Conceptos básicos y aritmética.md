# TEMA 2.1 - PROGRAMACIÓN A NIVEL-MÁQUINA I: CONCEPTOS BÁSICOS Y ARITMÉTICA

## §2.1.1 - Historia (no escrito)

## §2.1.2 - Lenguace C, ensamblador y código máquina

### Definiciones

- **Arquitectura:** Partes del diseño de un procesador, como la especificación del repertorio de instrucciones y los registros que lo componen, que se necesitan entender para escribir código ensamblador.
- **Código máquina:** Programas que ejecuta el procesador. **CODOPS, BYTES?**
- **Código ensamblador:** Representación textual del código máquina.
- **ISA:** *Instruction Set Architecture*, arquitectura del repertorio de instrucciones.
  - **ISAs Intel:** IA31, Itanium, x86-64.
  - **ARM:** ISA utilizada en casi todos los dispositivos móviles.
  - **RISC V:** Nueva ISA open source.
- **Microarquitectura:** Implementación de la arquitectura de un sistema, como el tamaño de las cachés y la frecuencia de los núcleos del procesador.

### Perspectiva de código ensamblador o máquina

Al ejecutar un programa compilado en código máquina, el programador tiene visibles una serie de estados del sistema.

En la **CPU** puede ver el estado del **PC** o contador de programa, llamado `%rip` (*instruction pointer*) en x86-64, que apunta a la dirección de la próxima instrucción a ejecutar.
También puede ver el **archivo de registros**, que almacena los datos del programa que se están usando en el momento, y los **flags de estado** o códigos de condición, que almacenan información sobre el estado de la operación aritmético-lógica más receiente (por ejemplo, si ha resultado en un bit de acarreo) y se utilizan para trabajar con bifurcación condicional (`if`, `for`...).

La **memoria** es un array direccionable por bytes en el que se encuentran almacenados el código y datos del programa que se está ejecutando y la pila, que es la que permite la ejecución estructurada de los programas.

A lo largo de la ejecución de un programa, la CPU suministra direcciones de memoria a la misma, que le facilita de vuelta a ésta instrucciones para que las procese.
Ambos dispositivos se encuentran en un constante intercambio de datos.

### Pasos de compilación de C a ensamblador

Sean dos ficheros de código fuente `p1.c` y `pc.2`.
Para compilar ambos ficheros combinados en un solo ejecutable `p`, hacemos uso del programa `gcc` con la siguiente sintaxis:

```shell
gcc -Og p1.c p2.c -o p
```

El argumento `-o <fichero>` indica que el ejecutable (`a.out` por defecto) se llamará `fichero`.
Podemos incluir optimizaciones en el código máquina mediante el argumento `-O<opt>`, donde `opt` puede valer `0` para no realizar ninguna optimización, `1-3` para tres niveles de opcimización y `g` para una optimización adecuada para depurar.

Para compilar, `gcc` convierte internamente el programa C (`p1.c`) a un programa ensamblador (`p1.asm`), que confierte en un módulo objeto (`p1.o`) y enlaza con otros módulos objeto y bibliotecas estáticas (`lib*.a`) en el ejecutable final.
Algunas bibliotecas son dinámicas, es decir, se enlazan cuando el programa empieza a ejecutarse.
Este proceso se ve en mucho más detalle en las prácticas 2.1 y 2.2.

El código ensamblador producido por `gcc` varía en función del nivel de optimización espedificado, la versión, ajustes y argumentos del compilador y la ISA de destino.

### Representación de datos C en IA32 y x86-64

| Tipo de dato  | Normal 32-bit | Intel IA32 | x86-64 |
| :------------ | ------------: | ---------: | -----: |
| `unsigned`    |             4 |          4 |      4 |
| `int`         |             4 |          4 |      4 |
| `long int`    |             4 |          4 |      8 |
| `char`        |             1 |          1 |      1 |
| `short`       |             2 |          2 |      2 |
| `float`       |             4 |          4 |      4 |
| `double`      |             8 |          8 |      8 |
| `long double` |             8 |      10/12 |     16 |
| `*`           |             4 |          4 |      8 |

Es responsabilidad del procesador interpretar los bytes leídos de la memoria como datos o instrucciones.
No existen tipos de datos abstractos, sino posiciones de memoria ubicadas contiguamente que el procesador interpreta como tales.

### Instrucciones ensamblador

Ensamblador cuenta con tres tipos básicos de instrucciones:

- **Operaciones:** Instrucciones aritmético-lógicas ejecutadas sobre datos en registros o memoria.
- ** Instrucciones de transferencia:** Cargan datos ubicados en memoria a registros del procesador y viceversa.
- **Instrucciones de control:** Pueden ser instrucciones incondicionales (saltos, llamadas a procedimientos, retorno desde procesos) o condicionales.

### Desensamblado de un ejecutable:

Podemos examinar el código máquina de un ejecutable y de un módulo objeto mediante `objdump -d <fichero>`, que analiza el `fichero` y produce una versión del código ensamblador aproximada pero correspondiente con el código ejecutado en el programa.

``` shell
g++ -O3 sum.cc -o sum
objdump -d sum
# 00000000004004c0 <main>:
#   4004c0:  b8 2d 00 00 00  mov   $0x2d,%eax
#   4004c5:  c3              retq
```

También podemos desensmblar desde `gdb` mediante su orden interna `disassemble <rutina>`, que desensambla la `rutina` al igual que `objdump -d` con información de apoyo para depurar.

## §2.1.3 - Conceptos básicos de ensamblador

### Registros

Los procesadores x86-64 tienen 16 registros de 64 bits:

`%rax`, `%rbx`, `%rcx` y `%rdx` son cuatro registros de propósito general que deben sus nombre a sus funciones históricas (*accumulator*, *base*, *counter* y *data*).
Se puede acceder únicamente a sus 32 primeros bits referenciándolos como `%eax`, `%ebx`, `%ecx` y `%edx`, a sus 16 primeros bits como `%ax`, `%bx`, `%cx` y `%dx` y a sus primeros 8 bits como `%al`, `%bl`, `%cl` y `%dl`.

`%rsi`, `%rdi`, `%rsp` y `%rbp` son dos registros de propósito general (*source index* y *destination index* respectivamente) y dos punteros (*stack pointer* y *base pointer* respectivamente).
Al igual que con los anteriores, pueden referenciarse sus 32 primeros bits como `%esi`, `%edi`, `%esp` y `%ebp`, sus 16 primeros bits como `%si`, `%di`, `%sp` y `%bp` y sus 8 primeros bits como `%sil`, `%dil`, `%spl` y `%bpl`, siendo `l` la abreviación de *low*.

Por último tenemos 8 registros `%r8-15` que pueden referenciarse a niveles inferiores como `%r8-15d`, `%r8-15w` (word) y `%r8-15b` (byte).

Todos estos registros pueden referenciarse también en sus cuatro, dos y un bits menos significativos, aunque esto es mucho menos común.

### Direccionamiento a memoria sencillo

Para leer una posición de memoria podemos direccionar de dos formas sencillas:

Cargada en un registro una dirección, podemos **desreferenciarla** (seguirla) y acceder directamente al dato al que apunta:

```asm
movq (%rcx), %rax
```

Conocida una posición de memoria y la distancia del dato que queremos leer de la misma, podemos referenciarla mediante un **offset** o desplazamiento prefijándolo a la dirección conocida:

```asm
movq 8(%rbp), %rdx
```

Tomemos como ejemplo el siguiente código C:

```c
void swap (long* a, long* b) {
	long l0 = *a;
	long l1 = *b;

	*a = l1;
	*b = l0;
}
```

Una vez compilado, esta rutina genera el siguiente código objeto:

```asm
swap:
	movq (%rdi), %rax # long l0 = *a
	movq (%rsi), %rdx # long l1 = *b
	movq %rdx, (%rdi) # *a = l1
	movq %rax, (%rsi) # *b = l0
	ret
```

Al comenzar la ejecución de la rutina, las direcciones de los dos argumentos que recibe están cargadas en `%rdi` y `%rsi` respectivamente.
Almacenamos el valor al que apunta `(%rdi)` en `%rax` y el valor al que apunta `(%rsi)` en `%rdx`.
Una vez hecho esto, teniendo los valores cargados en registros, podemos tomar `%rdx` y almacenarlo en `(%rdi)` y, aunque `(%rdi)` y `(%rsi)` son iguales, seguimos teniendo almacenado el valor antiguo de `(%rdi)` en `%rax`, por lo que podemos almacenar `%rax` en `(%rdi)` y completar el intercambio.

### Direccionamiento a memoria completo

Existe una forma más general de direccionar a memoria que obedece a la siguiente sintaxis:

\begin{center}
`d(rb,ri,s)` $\rightarrow Mem\Big[Reg[rb]+s\cdot Reg[ri]\Big]+d$
\end{center}

- **d:** Desplazamiento constante de 1, 2 ó 4 bytes.
- **rb:** Registro base. Cualquiera de los 16 registros enteros.
- **ri:** Registro índice. Cualquiera de los 16, excepto `%rsp`.
- **s:** Factor de escala: $1$, $2$, $4$ u $8$.

Podemos aplicar este direccionamiento con subconjuntos del mismo como `(rb,ri)`, `d(rb,ri)` o `(rb,ri,s)`.

Sea `%rdx = 0xf000` y sea `%rcx = 0x0100`, podemos obtener, por ejemplo, las siguientes posiciones de memoria:

| Expresión         | Cálculo de dirección     | Dirección |
| :---------------- | :----------------------- | :-------- |
| `0x8(%rdx)`       | `0xf000 + 0x8`           | `0xf008`  |
| `(%rdx,%rcx)`     | `0xf000 + 0x100`         | `0xf100`  |
| `(%rdx,%rcx,4)`   | `0xf000 + 0x100 *  4`    | `0xf400`  |
| `0x80(%rdx,%rcx)` | `0x80 + 0xf000 + 0x0100` | `0xf180`  |
| `0x80(,%rdx,2)`   | `2 * 0xf000 + 0x80`      | `0x1e080` |
