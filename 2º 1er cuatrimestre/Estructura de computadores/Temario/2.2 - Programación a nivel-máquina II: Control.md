# TEMA 2.2 - PROGRAMACIÓN A NIVEL-MÁQUINA II: CONTROL

## §2.2.1 - Control: Códigos de condición

### Estado del procesador x86-64

Los registros de propósito general almacenan información sobre el estado del programa que se encuentra en ejecución.
Los registros `%rax`, `%rbx`, `%rcx` y `%rdx` almacenan datos temporales sobre el porgrama, `%rsp` almacena la situación de la pila en tiempo de ejecución (*runtime stack*) y `%rip` la situación del contador de programa.
El estado de la última operación aritmético-lógica se almacena en las flags `CF`, `ZF`, `SF` y `OF`.

### Códigos de condición

Los códigos de condición, o flags de estado, pueden ajustarse implícitamente al realizar una operación airtmético-lógica o explícitamente mediante las instrucciones `cmp` (*compare*) y `test`.

| Flag | `cmp`                                        | `test`             |
| :--: | :------------------------------------------- | :----------------- |
| `CF` | Acarreo del MSB sin signo                    | -                  |
| `ZF` | `src1 == src2`                               | `(src1&src2) == 0` |
| `SF` | `(src1 - src2) < 0` con signo                | `(src1&src2) < 0`  |
| `OF` | Overflow en complemento a `2`[^of] con signo | -                  |

Para comprobar si un valor es $0$, `gcc` usa `test` y no `cmp`:

```asm
cmpq  $0,   %rax
testq %rax, %rax
```

### Consulta de códigos de condición

Las instrucciones de la familia `set` permiten ajustar el byte de destino a `0` ó `1` en función de las operaciones realizadas con una serie de flags.
El registro que se modifica **siempre** es de tamaño byte por lo que siempre se modifica el LSByte (`low`).

\pagebreak

Tengamos la siguiente rutina:

```c
int gt (long x, long y) {
	return x > y;
}
```

La traducimos a ensamblador de la siguiente forma:

```asm
gt:
	cmpq   %rsi, %rdi # Comparar x:y
	setg   %al        # Poner a 1 si x>y
	movzbl %al,  %eax # Poner el resto de %rax a 0
	ret
```

De esta forma, devolvemos `%eax` con el valor de la comparación `x>y`.

## §2.2.2 - Saltos condicionales

### Ejemplo convencional

Tengamos la siguiente rutina:

```c
long absdiff (long x, long y) {
	long result;

	if (x > y)
		result = x-y;
	else
		result = y-x;

	return result;
}
```

\pagebreak

La traducimos a ensamblador de la siguiente forma:

```asm
absdiff:
	cmpq %rsi, %rdi
	jle  .L4
	movq %rdi, %rax
	subq %rsi, %rax
	ret
.L4:
	movq %rsi, %rax
	subq %rdi, %rax
	ret
```

### Saltos con `goto` en C

Podemos realizar la misma operación con la instrucción `goto`, aunque es menos recomendable porque su uso excesivo produce espaguetización del código:

```c
long absdiff (long x, long y) {
	long result;

	int test = x <= y;

	if (test)
		goto Done

	result = x-y;
	goto Done

	Else:
		result = y-x;

	Done:

	return result;
}
```

\pagebreak

Este código generaría el siguiente código ensamblador:

```asm
absdiff:
	cmpq %rsi, %rdi
	jle  .L4
	movq %rdi, %rax
	subq %rsi, %rax
	jmp .L5
.L4:
	movq %rsi, %rax
	subq %rdi, %rax
.L5:
	ret
```

### Movimientos condicionales

Las instrucciones de movimiento condicional tienen la siguiente sintaxis (expresada siguiente el ejemplo de `absdiff`):

```c
val = x>y ? x-y : y-x;
```

El problema de su uso es que se evalúan todas las expresiones contenidas en ellas.
En el caso de la sentencia anterior, éste sería su equivalente:

```c
result = x-y;
other  = y-x;
test   = !(x>y);

if (test)
	result = other;

return result;
```

Como se calculan ambos valores, estas expresiones son muy ineficientes para algunos casos:

```c
// Cálculos costosos
result = Test(x) ? OFactorial1(x) : OFactorial2(x);
// Cálculos arriesgados
result = p = *p : 0;
// Secciones críticas
result = x%2 ? x/=2 : x=(x*3)+=1
```

## §2.2.3 - Bucles

### Bucle Do-While

Tengamos el siguiente bucle:

```c
long pcount (unsigned long x) {
	unsigned long result = 0;

	do {
		result += x & 0x1;
		x >>= 1;
	} while (x);

	return result;
}
```

Podríamos escribirlo de esta manera con sentencias `goto`:

```c
long pcount (unsigned long x) {
	unsigned long result = 0;

	loop:
		result += x & 0x1;
		x >>= 1;

	if (x)
		goto loop;

	return result;
}
```

Este código generaría el siguiente código ensamblador:

```asm
	movl $0, %eax
.L2
	movq %rdi, %rdx
	andl $1,   %edx # tmp = X & 0x1;
	addq %rdx, %rax # result += tmp;
	shrq %rdi       # x >>= 1;
	jne  .L2        # if (x) goto loop;
	rep
	ret
```

### Do-While vs While

La diferencia principal entre un bucle Do-While y un bucle While es que el primero realiza las operaciones del bucle y luego la comprobación y el segundo lo hace a la inversa.
Traducidos a código C con sentencias `goto`, ambos quedan de la siguiente forma:

**Do-While:**

```c
do {
	// Cosas
} while (test);

// Es equivalente a:

loop:
	// Cosas

	if (test)
		goto loop;
```

**While:**

```c
while (test) {
	// Cosas
}

// Es equivalente a:

	goto test;

loop:
	// Cosas

test:
	if (test)
		goto loop;
```

El `goto` previo al bucle `while` es lo que se conoce como un salto en medio (*jump to middle*).

### Bucles For

Al compilar un bucle `for`, gcc lo traduce a un bucle `while` de la siguiente forma:

`for (init; test; update) { body }` $\rightarrow$ `init; while (test) { body; update; }`

## §2.2.4 - Sentencias switch

Las sentencias switch se implementan mediante una tabla de saltos, de forma que se almacenan todos los valores que puede tomar la expresión que se compara en ella y se usa de referencia para realizar los saltos.
Sinceramente, tengo muy pocas ganas de explicarlo, míralo en los apuntes.

[^of]: `(src1>0 && src2<0 && (src1-src2)<0) || (src1<0 && src2>0 && (src1-src2)>0)
