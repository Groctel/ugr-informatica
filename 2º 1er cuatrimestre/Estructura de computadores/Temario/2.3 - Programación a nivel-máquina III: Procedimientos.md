# TEMA 2.3 - PROGRAMACIÓN A NIVEL-MÁQUINA III: PROCEDIMIENTOS

## §2.3.1 - Mecanismos

Tengamos el siguiente programa C:

```c
unsigned sumauno (unsigned x) {
	return x+1;
}

int main () {
	unsigned x = 0;

	x = sumauno(x);

	return 0;
}
```

En la sentencia `x = sumauno(x)`, transferimos el control del programa a la rutina `sumauno`, de forma que ésta se añade a la pila y se coloca el contador de programa al principio de la misma.
Su sentencia `return` devuelve el control a `main` en la misma sentencia en la que se quedó al transferir el control a `sumauno`.

De la misma forma que se transfiere el control, se transfieren los argumentos de la rutina y los valores de retorno cargándolos en sus registros correspondientes.

Cuando se está ejecutando en una rutina, se reserva la memoria necesaria para trabajar con los datos que se especifican en ella.
Por ejemplo, en `main` reservamos memoria suficiente para almacenar un `unsigned`.

## §2.3.2 - Estructura de la pila

La pila x86-64 es una región de memoria que se gestiona con la estructura de datos homónima, de forma que el fondo (*bottom*) se encuentra en la dirección más alta y el tope (*top*) en la más baja.
El registro `%rsp` apunta siempre al tope de la pila.
Sobre esta pila podemos realizar las instrucciones `push` y `pop`.

## §2.3.3 - Convenciones de llamada

### Paso de control

Las llamadas a las rutinas se hacen mediante la orden `call`.
La dirección de retorno de la rutina, a la que se vuelve con `ret`, es la instrucción inmediatamente siguiente a la que realiza la llamada.

### Paso de datos

El orden en que se cargan los argumentos de una rutina es siempre `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8` y `%r9`, que responde a la regla mnemotécnica *Diane's silk dress costs \$89*.
El resto de argumentos se almacenan en la pila, en la que se reserva el espacio imprescindible.

### Gestión de datos locales

Los lenguajes basados en la pila (*block structured languages*) – C, Pascal, Java...– permiten crear programas con rutinas recursivas, es decir, que permitan crear nuevas instanciaciones de una rutina a partir de ella misma.
Para ello, se necesita guardar el estado de cada instanciación, que está formado por los argumentos de la rutina, sus variables locales y el puntero de la dirección de retorno.

Los datos de cada rutina quedan almacenados en la pila en marcos (*allocated in frames*) durante un tiempo limitado hasta que se vuelve a ella.
Cada uno de estos marcos contienen el código de inicialización y finalización de la rutina, el `push` de la instrucción `call` para la reserva en entrada y el `pop` de la instrucción `ret` para la liberación de retorno.

Como consecuencia de esta estructura de pila, la rutina invocada **siempre** retorna (`ret`) antes que la rutina invocante.

### Marco de pila x86-64/Linux

El marco de pila de una rutina invocada en Linux contiene, en orden de salida, los siguientes elementos:

- **Confección de lista de argumentos:** Contiene los argumentos a partir del séptimo de la rutina que se va a llamar.
- **Variables locales:** Sólo se almacenan las que no se pueden mantener en registros.
- **Contexto de registros preservados.**
- **Antiguo puntero de marco (`%rbp`):** Opcional, sólo se utiliza si se compila con `-fno-omit-frame-pointer` o `-O0`.

Por otro lado, el marco de pila del invocante contiene la dirección de retorno guardada por la instrucción `call` aparta del resto de elementos de rutina invocada.

### Convenciones de preservación de registros

Tengamos las dos siguientes rutinas en ensamblador:

```asm
ooo:
	movq $100, %rdx
	call wee
	addq %rdx, %rax
	ret
wee:
	# ...
	subq $50,  %rdx
	# ...
	ret
```

Si no estamos esperando que `wee` tome el dato guardado en `%rdx` por `ooo`, tenemos el problema de que ambas rutinas van a enviar valores equivocados (`ooo` esperaba trabajar con `$100` y `wee` con `$-50`).
Para subsanar esto, podemos usar registros de almacenamiento temporal según dos convenciones:

- **Salva-invocante (*caller save*):** La rutina invocante almacena los valores temporales en su marco antes de la llamada.
- **Salva-invocado (*callee save*):** La rutina invocada almacena los valores temporales en su marco antes de usar los registros y los restaura al devolver el control a la rutina invocante.

Los registros salva-invocantes son `%rax`, que almacena el valor de retorno, los registros `%rdi` a `%9`, que almacenan los seis primeros argumentos de la rutina invocada, y `%r10` y `%r11`, que almacenan datos temporales.
Es responsabilidad del invocante  almacenarlos en la pila para que no se modifiquen de forma no deseada.

Por otro lado, son registros salva-invocados `%rbx` y `%r12-%r15`, que contienen datos temporales, `%rbp` y `%rsp`.
Es responsabilidad del invocado almacenarlos en su marco y restaurarlos en el retorno.

