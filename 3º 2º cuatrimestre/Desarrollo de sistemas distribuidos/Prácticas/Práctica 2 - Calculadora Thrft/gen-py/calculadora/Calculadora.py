#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def Ping(self):
        pass

    def SumaEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def RestaEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def ProductoEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def DivisionEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def SumaVectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def RestaVectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def ProductoVectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def SumaMatricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def RestaMatricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def ProductoMatricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def Ping(self):
        self.send_Ping()
        self.recv_Ping()

    def send_Ping(self):
        self._oprot.writeMessageBegin('Ping', TMessageType.CALL, self._seqid)
        args = Ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def SumaEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_SumaEscalar(operando1, operando2)
        return self.recv_SumaEscalar()

    def send_SumaEscalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('SumaEscalar', TMessageType.CALL, self._seqid)
        args = SumaEscalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SumaEscalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SumaEscalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SumaEscalar failed: unknown result")

    def RestaEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_RestaEscalar(operando1, operando2)
        return self.recv_RestaEscalar()

    def send_RestaEscalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('RestaEscalar', TMessageType.CALL, self._seqid)
        args = RestaEscalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RestaEscalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RestaEscalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RestaEscalar failed: unknown result")

    def ProductoEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_ProductoEscalar(operando1, operando2)
        return self.recv_ProductoEscalar()

    def send_ProductoEscalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('ProductoEscalar', TMessageType.CALL, self._seqid)
        args = ProductoEscalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ProductoEscalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ProductoEscalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ProductoEscalar failed: unknown result")

    def DivisionEscalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_DivisionEscalar(operando1, operando2)
        return self.recv_DivisionEscalar()

    def send_DivisionEscalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('DivisionEscalar', TMessageType.CALL, self._seqid)
        args = DivisionEscalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DivisionEscalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DivisionEscalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DivisionEscalar failed: unknown result")

    def SumaVectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_SumaVectorial(operando1, operando2)
        return self.recv_SumaVectorial()

    def send_SumaVectorial(self, operando1, operando2):
        self._oprot.writeMessageBegin('SumaVectorial', TMessageType.CALL, self._seqid)
        args = SumaVectorial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SumaVectorial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SumaVectorial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SumaVectorial failed: unknown result")

    def RestaVectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_RestaVectorial(operando1, operando2)
        return self.recv_RestaVectorial()

    def send_RestaVectorial(self, operando1, operando2):
        self._oprot.writeMessageBegin('RestaVectorial', TMessageType.CALL, self._seqid)
        args = RestaVectorial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RestaVectorial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RestaVectorial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RestaVectorial failed: unknown result")

    def ProductoVectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_ProductoVectorial(operando1, operando2)
        return self.recv_ProductoVectorial()

    def send_ProductoVectorial(self, operando1, operando2):
        self._oprot.writeMessageBegin('ProductoVectorial', TMessageType.CALL, self._seqid)
        args = ProductoVectorial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ProductoVectorial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ProductoVectorial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ProductoVectorial failed: unknown result")

    def SumaMatricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_SumaMatricial(operando1, operando2)
        return self.recv_SumaMatricial()

    def send_SumaMatricial(self, operando1, operando2):
        self._oprot.writeMessageBegin('SumaMatricial', TMessageType.CALL, self._seqid)
        args = SumaMatricial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SumaMatricial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SumaMatricial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SumaMatricial failed: unknown result")

    def RestaMatricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_RestaMatricial(operando1, operando2)
        return self.recv_RestaMatricial()

    def send_RestaMatricial(self, operando1, operando2):
        self._oprot.writeMessageBegin('RestaMatricial', TMessageType.CALL, self._seqid)
        args = RestaMatricial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RestaMatricial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RestaMatricial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RestaMatricial failed: unknown result")

    def ProductoMatricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_ProductoMatricial(operando1, operando2)
        return self.recv_ProductoMatricial()

    def send_ProductoMatricial(self, operando1, operando2):
        self._oprot.writeMessageBegin('ProductoMatricial', TMessageType.CALL, self._seqid)
        args = ProductoMatricial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ProductoMatricial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ProductoMatricial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ProductoMatricial failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["Ping"] = Processor.process_Ping
        self._processMap["SumaEscalar"] = Processor.process_SumaEscalar
        self._processMap["RestaEscalar"] = Processor.process_RestaEscalar
        self._processMap["ProductoEscalar"] = Processor.process_ProductoEscalar
        self._processMap["DivisionEscalar"] = Processor.process_DivisionEscalar
        self._processMap["SumaVectorial"] = Processor.process_SumaVectorial
        self._processMap["RestaVectorial"] = Processor.process_RestaVectorial
        self._processMap["ProductoVectorial"] = Processor.process_ProductoVectorial
        self._processMap["SumaMatricial"] = Processor.process_SumaMatricial
        self._processMap["RestaMatricial"] = Processor.process_RestaMatricial
        self._processMap["ProductoMatricial"] = Processor.process_ProductoMatricial
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_Ping(self, seqid, iprot, oprot):
        args = Ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Ping_result()
        try:
            self._handler.Ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SumaEscalar(self, seqid, iprot, oprot):
        args = SumaEscalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SumaEscalar_result()
        try:
            result.success = self._handler.SumaEscalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SumaEscalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RestaEscalar(self, seqid, iprot, oprot):
        args = RestaEscalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RestaEscalar_result()
        try:
            result.success = self._handler.RestaEscalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RestaEscalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ProductoEscalar(self, seqid, iprot, oprot):
        args = ProductoEscalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ProductoEscalar_result()
        try:
            result.success = self._handler.ProductoEscalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ProductoEscalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DivisionEscalar(self, seqid, iprot, oprot):
        args = DivisionEscalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DivisionEscalar_result()
        try:
            result.success = self._handler.DivisionEscalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DivisionEscalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SumaVectorial(self, seqid, iprot, oprot):
        args = SumaVectorial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SumaVectorial_result()
        try:
            result.success = self._handler.SumaVectorial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SumaVectorial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RestaVectorial(self, seqid, iprot, oprot):
        args = RestaVectorial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RestaVectorial_result()
        try:
            result.success = self._handler.RestaVectorial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RestaVectorial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ProductoVectorial(self, seqid, iprot, oprot):
        args = ProductoVectorial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ProductoVectorial_result()
        try:
            result.success = self._handler.ProductoVectorial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ProductoVectorial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SumaMatricial(self, seqid, iprot, oprot):
        args = SumaMatricial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SumaMatricial_result()
        try:
            result.success = self._handler.SumaMatricial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SumaMatricial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RestaMatricial(self, seqid, iprot, oprot):
        args = RestaMatricial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RestaMatricial_result()
        try:
            result.success = self._handler.RestaMatricial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RestaMatricial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ProductoMatricial(self, seqid, iprot, oprot):
        args = ProductoMatricial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ProductoMatricial_result()
        try:
            result.success = self._handler.ProductoMatricial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ProductoMatricial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class Ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Ping_args)
Ping_args.thrift_spec = (
)


class Ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Ping_result)
Ping_result.thrift_spec = (
)


class SumaEscalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SumaEscalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SumaEscalar_args)
SumaEscalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class SumaEscalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SumaEscalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SumaEscalar_result)
SumaEscalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class RestaEscalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestaEscalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestaEscalar_args)
RestaEscalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class RestaEscalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestaEscalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestaEscalar_result)
RestaEscalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class ProductoEscalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProductoEscalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProductoEscalar_args)
ProductoEscalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class ProductoEscalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProductoEscalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProductoEscalar_result)
ProductoEscalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class DivisionEscalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DivisionEscalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DivisionEscalar_args)
DivisionEscalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class DivisionEscalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DivisionEscalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DivisionEscalar_result)
DivisionEscalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SumaVectorial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.operando1.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.operando2.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SumaVectorial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.operando1))
            for iter12 in self.operando1:
                oprot.writeI32(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.operando2))
            for iter13 in self.operando2:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SumaVectorial_args)
SumaVectorial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.I32, None, False), None, ),  # 2
)


class SumaVectorial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI32()
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SumaVectorial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter20 in self.success:
                oprot.writeI32(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SumaVectorial_result)
SumaVectorial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class RestaVectorial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI32()
                        self.operando1.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readI32()
                        self.operando2.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestaVectorial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.operando1))
            for iter33 in self.operando1:
                oprot.writeI32(iter33)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.operando2))
            for iter34 in self.operando2:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestaVectorial_args)
RestaVectorial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.I32, None, False), None, ),  # 2
)


class RestaVectorial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI32()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestaVectorial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter41 in self.success:
                oprot.writeI32(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestaVectorial_result)
RestaVectorial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class ProductoVectorial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI32()
                        self.operando1.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readI32()
                        self.operando2.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProductoVectorial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.operando1))
            for iter54 in self.operando1:
                oprot.writeI32(iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.operando2))
            for iter55 in self.operando2:
                oprot.writeI32(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProductoVectorial_args)
ProductoVectorial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.I32, None, False), None, ),  # 2
)


class ProductoVectorial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readI32()
                        self.success.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProductoVectorial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter62 in self.success:
                oprot.writeI32(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProductoVectorial_result)
ProductoVectorial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class SumaMatricial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = []
                        (_etype72, _size69) = iprot.readListBegin()
                        for _i73 in range(_size69):
                            _elem74 = iprot.readI32()
                            _elem68.append(_elem74)
                        iprot.readListEnd()
                        self.operando1.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype78, _size75) = iprot.readListBegin()
                    for _i79 in range(_size75):
                        _elem80 = []
                        (_etype84, _size81) = iprot.readListBegin()
                        for _i85 in range(_size81):
                            _elem86 = iprot.readI32()
                            _elem80.append(_elem86)
                        iprot.readListEnd()
                        self.operando2.append(_elem80)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SumaMatricial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.operando1))
            for iter87 in self.operando1:
                oprot.writeListBegin(TType.I32, len(iter87))
                for iter88 in iter87:
                    oprot.writeI32(iter88)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.operando2))
            for iter89 in self.operando2:
                oprot.writeListBegin(TType.I32, len(iter89))
                for iter90 in iter89:
                    oprot.writeI32(iter90)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SumaMatricial_args)
SumaMatricial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.LIST, (TType.I32, None, False), False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)


class SumaMatricial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = []
                        (_etype100, _size97) = iprot.readListBegin()
                        for _i101 in range(_size97):
                            _elem102 = iprot.readI32()
                            _elem96.append(_elem102)
                        iprot.readListEnd()
                        self.success.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SumaMatricial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter103 in self.success:
                oprot.writeListBegin(TType.I32, len(iter103))
                for iter104 in iter103:
                    oprot.writeI32(iter104)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SumaMatricial_result)
SumaMatricial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.I32, None, False), False), None, ),  # 0
)


class RestaMatricial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = []
                        (_etype114, _size111) = iprot.readListBegin()
                        for _i115 in range(_size111):
                            _elem116 = iprot.readI32()
                            _elem110.append(_elem116)
                        iprot.readListEnd()
                        self.operando1.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype120, _size117) = iprot.readListBegin()
                    for _i121 in range(_size117):
                        _elem122 = []
                        (_etype126, _size123) = iprot.readListBegin()
                        for _i127 in range(_size123):
                            _elem128 = iprot.readI32()
                            _elem122.append(_elem128)
                        iprot.readListEnd()
                        self.operando2.append(_elem122)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestaMatricial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.operando1))
            for iter129 in self.operando1:
                oprot.writeListBegin(TType.I32, len(iter129))
                for iter130 in iter129:
                    oprot.writeI32(iter130)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.operando2))
            for iter131 in self.operando2:
                oprot.writeListBegin(TType.I32, len(iter131))
                for iter132 in iter131:
                    oprot.writeI32(iter132)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestaMatricial_args)
RestaMatricial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.LIST, (TType.I32, None, False), False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)


class RestaMatricial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = []
                        (_etype142, _size139) = iprot.readListBegin()
                        for _i143 in range(_size139):
                            _elem144 = iprot.readI32()
                            _elem138.append(_elem144)
                        iprot.readListEnd()
                        self.success.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestaMatricial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter145 in self.success:
                oprot.writeListBegin(TType.I32, len(iter145))
                for iter146 in iter145:
                    oprot.writeI32(iter146)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestaMatricial_result)
RestaMatricial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.I32, None, False), False), None, ),  # 0
)


class ProductoMatricial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = []
                        (_etype156, _size153) = iprot.readListBegin()
                        for _i157 in range(_size153):
                            _elem158 = iprot.readI32()
                            _elem152.append(_elem158)
                        iprot.readListEnd()
                        self.operando1.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = []
                        (_etype168, _size165) = iprot.readListBegin()
                        for _i169 in range(_size165):
                            _elem170 = iprot.readI32()
                            _elem164.append(_elem170)
                        iprot.readListEnd()
                        self.operando2.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProductoMatricial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.operando1))
            for iter171 in self.operando1:
                oprot.writeListBegin(TType.I32, len(iter171))
                for iter172 in iter171:
                    oprot.writeI32(iter172)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.operando2))
            for iter173 in self.operando2:
                oprot.writeListBegin(TType.I32, len(iter173))
                for iter174 in iter173:
                    oprot.writeI32(iter174)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProductoMatricial_args)
ProductoMatricial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.LIST, (TType.I32, None, False), False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)


class ProductoMatricial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype178, _size175) = iprot.readListBegin()
                    for _i179 in range(_size175):
                        _elem180 = []
                        (_etype184, _size181) = iprot.readListBegin()
                        for _i185 in range(_size181):
                            _elem186 = iprot.readI32()
                            _elem180.append(_elem186)
                        iprot.readListEnd()
                        self.success.append(_elem180)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ProductoMatricial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter187 in self.success:
                oprot.writeListBegin(TType.I32, len(iter187))
                for iter188 in iter187:
                    oprot.writeI32(iter188)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ProductoMatricial_result)
ProductoMatricial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.I32, None, False), False), None, ),  # 0
)
fix_spec(all_structs)
del all_structs
