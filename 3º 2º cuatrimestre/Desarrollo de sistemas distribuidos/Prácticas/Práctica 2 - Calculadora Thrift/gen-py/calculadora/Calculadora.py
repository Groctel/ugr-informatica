#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def ping(self):
        pass

    def suma_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def resta_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def producto_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def division_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def suma_vectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def resta_vectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def producto_vectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def suma_matricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def resta_matricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass

    def producto_matricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        self.send_ping()
        self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def suma_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_suma_escalar(operando1, operando2)
        return self.recv_suma_escalar()

    def send_suma_escalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('suma_escalar', TMessageType.CALL, self._seqid)
        args = suma_escalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_suma_escalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = suma_escalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "suma_escalar failed: unknown result")

    def resta_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_resta_escalar(operando1, operando2)
        return self.recv_resta_escalar()

    def send_resta_escalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('resta_escalar', TMessageType.CALL, self._seqid)
        args = resta_escalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resta_escalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resta_escalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resta_escalar failed: unknown result")

    def producto_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_producto_escalar(operando1, operando2)
        return self.recv_producto_escalar()

    def send_producto_escalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('producto_escalar', TMessageType.CALL, self._seqid)
        args = producto_escalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_producto_escalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = producto_escalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "producto_escalar failed: unknown result")

    def division_escalar(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_division_escalar(operando1, operando2)
        return self.recv_division_escalar()

    def send_division_escalar(self, operando1, operando2):
        self._oprot.writeMessageBegin('division_escalar', TMessageType.CALL, self._seqid)
        args = division_escalar_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_division_escalar(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = division_escalar_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "division_escalar failed: unknown result")

    def suma_vectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_suma_vectorial(operando1, operando2)
        return self.recv_suma_vectorial()

    def send_suma_vectorial(self, operando1, operando2):
        self._oprot.writeMessageBegin('suma_vectorial', TMessageType.CALL, self._seqid)
        args = suma_vectorial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_suma_vectorial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = suma_vectorial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "suma_vectorial failed: unknown result")

    def resta_vectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_resta_vectorial(operando1, operando2)
        return self.recv_resta_vectorial()

    def send_resta_vectorial(self, operando1, operando2):
        self._oprot.writeMessageBegin('resta_vectorial', TMessageType.CALL, self._seqid)
        args = resta_vectorial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resta_vectorial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resta_vectorial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resta_vectorial failed: unknown result")

    def producto_vectorial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_producto_vectorial(operando1, operando2)
        return self.recv_producto_vectorial()

    def send_producto_vectorial(self, operando1, operando2):
        self._oprot.writeMessageBegin('producto_vectorial', TMessageType.CALL, self._seqid)
        args = producto_vectorial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_producto_vectorial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = producto_vectorial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "producto_vectorial failed: unknown result")

    def suma_matricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_suma_matricial(operando1, operando2)
        return self.recv_suma_matricial()

    def send_suma_matricial(self, operando1, operando2):
        self._oprot.writeMessageBegin('suma_matricial', TMessageType.CALL, self._seqid)
        args = suma_matricial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_suma_matricial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = suma_matricial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "suma_matricial failed: unknown result")

    def resta_matricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_resta_matricial(operando1, operando2)
        return self.recv_resta_matricial()

    def send_resta_matricial(self, operando1, operando2):
        self._oprot.writeMessageBegin('resta_matricial', TMessageType.CALL, self._seqid)
        args = resta_matricial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resta_matricial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resta_matricial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resta_matricial failed: unknown result")

    def producto_matricial(self, operando1, operando2):
        """
        Parameters:
         - operando1
         - operando2

        """
        self.send_producto_matricial(operando1, operando2)
        return self.recv_producto_matricial()

    def send_producto_matricial(self, operando1, operando2):
        self._oprot.writeMessageBegin('producto_matricial', TMessageType.CALL, self._seqid)
        args = producto_matricial_args()
        args.operando1 = operando1
        args.operando2 = operando2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_producto_matricial(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = producto_matricial_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "producto_matricial failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["suma_escalar"] = Processor.process_suma_escalar
        self._processMap["resta_escalar"] = Processor.process_resta_escalar
        self._processMap["producto_escalar"] = Processor.process_producto_escalar
        self._processMap["division_escalar"] = Processor.process_division_escalar
        self._processMap["suma_vectorial"] = Processor.process_suma_vectorial
        self._processMap["resta_vectorial"] = Processor.process_resta_vectorial
        self._processMap["producto_vectorial"] = Processor.process_producto_vectorial
        self._processMap["suma_matricial"] = Processor.process_suma_matricial
        self._processMap["resta_matricial"] = Processor.process_resta_matricial
        self._processMap["producto_matricial"] = Processor.process_producto_matricial
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_suma_escalar(self, seqid, iprot, oprot):
        args = suma_escalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = suma_escalar_result()
        try:
            result.success = self._handler.suma_escalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("suma_escalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resta_escalar(self, seqid, iprot, oprot):
        args = resta_escalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resta_escalar_result()
        try:
            result.success = self._handler.resta_escalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resta_escalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_producto_escalar(self, seqid, iprot, oprot):
        args = producto_escalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = producto_escalar_result()
        try:
            result.success = self._handler.producto_escalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("producto_escalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_division_escalar(self, seqid, iprot, oprot):
        args = division_escalar_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = division_escalar_result()
        try:
            result.success = self._handler.division_escalar(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("division_escalar", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_suma_vectorial(self, seqid, iprot, oprot):
        args = suma_vectorial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = suma_vectorial_result()
        try:
            result.success = self._handler.suma_vectorial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("suma_vectorial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resta_vectorial(self, seqid, iprot, oprot):
        args = resta_vectorial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resta_vectorial_result()
        try:
            result.success = self._handler.resta_vectorial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resta_vectorial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_producto_vectorial(self, seqid, iprot, oprot):
        args = producto_vectorial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = producto_vectorial_result()
        try:
            result.success = self._handler.producto_vectorial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("producto_vectorial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_suma_matricial(self, seqid, iprot, oprot):
        args = suma_matricial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = suma_matricial_result()
        try:
            result.success = self._handler.suma_matricial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("suma_matricial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resta_matricial(self, seqid, iprot, oprot):
        args = resta_matricial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resta_matricial_result()
        try:
            result.success = self._handler.resta_matricial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resta_matricial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_producto_matricial(self, seqid, iprot, oprot):
        args = producto_matricial_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = producto_matricial_result()
        try:
            result.success = self._handler.producto_matricial(args.operando1, args.operando2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("producto_matricial", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
)


class suma_escalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_escalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_escalar_args)
suma_escalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class suma_escalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_escalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_escalar_result)
suma_escalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class resta_escalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_escalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_escalar_args)
resta_escalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class resta_escalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_escalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_escalar_result)
resta_escalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class producto_escalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_escalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_escalar_args)
producto_escalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class producto_escalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_escalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_escalar_result)
producto_escalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class division_escalar_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.operando1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operando2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('division_escalar_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.I32, 1)
            oprot.writeI32(self.operando1)
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.I32, 2)
            oprot.writeI32(self.operando2)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(division_escalar_args)
division_escalar_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'operando1', None, None, ),  # 1
    (2, TType.I32, 'operando2', None, None, ),  # 2
)


class division_escalar_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('division_escalar_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(division_escalar_result)
division_escalar_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class suma_vectorial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.operando1.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.operando2.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_vectorial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.operando1))
            for iter12 in self.operando1:
                oprot.writeI32(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.operando2))
            for iter13 in self.operando2:
                oprot.writeI32(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_vectorial_args)
suma_vectorial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.I32, None, False), None, ),  # 2
)


class suma_vectorial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readI32()
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_vectorial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter20 in self.success:
                oprot.writeI32(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_vectorial_result)
suma_vectorial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class resta_vectorial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI32()
                        self.operando1.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readI32()
                        self.operando2.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_vectorial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.operando1))
            for iter33 in self.operando1:
                oprot.writeI32(iter33)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.operando2))
            for iter34 in self.operando2:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_vectorial_args)
resta_vectorial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.I32, None, False), None, ),  # 2
)


class resta_vectorial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI32()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_vectorial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter41 in self.success:
                oprot.writeI32(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_vectorial_result)
resta_vectorial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class producto_vectorial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI32()
                        self.operando1.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readI32()
                        self.operando2.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_vectorial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.operando1))
            for iter54 in self.operando1:
                oprot.writeI32(iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.operando2))
            for iter55 in self.operando2:
                oprot.writeI32(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_vectorial_args)
producto_vectorial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.I32, None, False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.I32, None, False), None, ),  # 2
)


class producto_vectorial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readI32()
                        self.success.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_vectorial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter62 in self.success:
                oprot.writeI32(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_vectorial_result)
producto_vectorial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class suma_matricial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = []
                        (_etype72, _size69) = iprot.readListBegin()
                        for _i73 in range(_size69):
                            _elem74 = iprot.readI32()
                            _elem68.append(_elem74)
                        iprot.readListEnd()
                        self.operando1.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype78, _size75) = iprot.readListBegin()
                    for _i79 in range(_size75):
                        _elem80 = []
                        (_etype84, _size81) = iprot.readListBegin()
                        for _i85 in range(_size81):
                            _elem86 = iprot.readI32()
                            _elem80.append(_elem86)
                        iprot.readListEnd()
                        self.operando2.append(_elem80)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_matricial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.operando1))
            for iter87 in self.operando1:
                oprot.writeListBegin(TType.I32, len(iter87))
                for iter88 in iter87:
                    oprot.writeI32(iter88)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.operando2))
            for iter89 in self.operando2:
                oprot.writeListBegin(TType.I32, len(iter89))
                for iter90 in iter89:
                    oprot.writeI32(iter90)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_matricial_args)
suma_matricial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.LIST, (TType.I32, None, False), False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)


class suma_matricial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = []
                        (_etype100, _size97) = iprot.readListBegin()
                        for _i101 in range(_size97):
                            _elem102 = iprot.readI32()
                            _elem96.append(_elem102)
                        iprot.readListEnd()
                        self.success.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('suma_matricial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter103 in self.success:
                oprot.writeListBegin(TType.I32, len(iter103))
                for iter104 in iter103:
                    oprot.writeI32(iter104)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(suma_matricial_result)
suma_matricial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.I32, None, False), False), None, ),  # 0
)


class resta_matricial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = []
                        (_etype114, _size111) = iprot.readListBegin()
                        for _i115 in range(_size111):
                            _elem116 = iprot.readI32()
                            _elem110.append(_elem116)
                        iprot.readListEnd()
                        self.operando1.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype120, _size117) = iprot.readListBegin()
                    for _i121 in range(_size117):
                        _elem122 = []
                        (_etype126, _size123) = iprot.readListBegin()
                        for _i127 in range(_size123):
                            _elem128 = iprot.readI32()
                            _elem122.append(_elem128)
                        iprot.readListEnd()
                        self.operando2.append(_elem122)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_matricial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.operando1))
            for iter129 in self.operando1:
                oprot.writeListBegin(TType.I32, len(iter129))
                for iter130 in iter129:
                    oprot.writeI32(iter130)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.operando2))
            for iter131 in self.operando2:
                oprot.writeListBegin(TType.I32, len(iter131))
                for iter132 in iter131:
                    oprot.writeI32(iter132)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_matricial_args)
resta_matricial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.LIST, (TType.I32, None, False), False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)


class resta_matricial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = []
                        (_etype142, _size139) = iprot.readListBegin()
                        for _i143 in range(_size139):
                            _elem144 = iprot.readI32()
                            _elem138.append(_elem144)
                        iprot.readListEnd()
                        self.success.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resta_matricial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter145 in self.success:
                oprot.writeListBegin(TType.I32, len(iter145))
                for iter146 in iter145:
                    oprot.writeI32(iter146)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resta_matricial_result)
resta_matricial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.I32, None, False), False), None, ),  # 0
)


class producto_matricial_args(object):
    """
    Attributes:
     - operando1
     - operando2

    """


    def __init__(self, operando1=None, operando2=None,):
        self.operando1 = operando1
        self.operando2 = operando2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operando1 = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = []
                        (_etype156, _size153) = iprot.readListBegin()
                        for _i157 in range(_size153):
                            _elem158 = iprot.readI32()
                            _elem152.append(_elem158)
                        iprot.readListEnd()
                        self.operando1.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.operando2 = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = []
                        (_etype168, _size165) = iprot.readListBegin()
                        for _i169 in range(_size165):
                            _elem170 = iprot.readI32()
                            _elem164.append(_elem170)
                        iprot.readListEnd()
                        self.operando2.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_matricial_args')
        if self.operando1 is not None:
            oprot.writeFieldBegin('operando1', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.operando1))
            for iter171 in self.operando1:
                oprot.writeListBegin(TType.I32, len(iter171))
                for iter172 in iter171:
                    oprot.writeI32(iter172)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operando2 is not None:
            oprot.writeFieldBegin('operando2', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.operando2))
            for iter173 in self.operando2:
                oprot.writeListBegin(TType.I32, len(iter173))
                for iter174 in iter173:
                    oprot.writeI32(iter174)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_matricial_args)
producto_matricial_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operando1', (TType.LIST, (TType.I32, None, False), False), None, ),  # 1
    (2, TType.LIST, 'operando2', (TType.LIST, (TType.I32, None, False), False), None, ),  # 2
)


class producto_matricial_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype178, _size175) = iprot.readListBegin()
                    for _i179 in range(_size175):
                        _elem180 = []
                        (_etype184, _size181) = iprot.readListBegin()
                        for _i185 in range(_size181):
                            _elem186 = iprot.readI32()
                            _elem180.append(_elem186)
                        iprot.readListEnd()
                        self.success.append(_elem180)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('producto_matricial_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter187 in self.success:
                oprot.writeListBegin(TType.I32, len(iter187))
                for iter188 in iter187:
                    oprot.writeI32(iter188)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(producto_matricial_result)
producto_matricial_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.I32, None, False), False), None, ),  # 0
)
fix_spec(all_structs)
del all_structs
