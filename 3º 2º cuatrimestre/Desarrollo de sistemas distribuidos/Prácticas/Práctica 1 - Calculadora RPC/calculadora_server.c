/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"

#define min(a,b) (((a)<(b))?(a):(b))

resultado_escalar *
suma_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static resultado_escalar  result;

	xdr_free((xdrproc_t) xdr_resultado_escalar, &result);
	result.resultado_escalar_u.resultado = arg1 + arg2;

	return &result;
}

resultado_escalar *
resta_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static resultado_escalar  result;

	xdr_free((xdrproc_t) xdr_resultado_escalar, &result);
	result.resultado_escalar_u.resultado = arg1 - arg2;

	return &result;
}

resultado_escalar *
producto_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static resultado_escalar  result;

	xdr_free((xdrproc_t) xdr_resultado_escalar, &result);
	result.resultado_escalar_u.resultado = arg1 * arg2;

	return &result;
}

resultado_escalar *
cociente_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static resultado_escalar  result;

	xdr_free((xdrproc_t) xdr_resultado_escalar, &result);
	result.resultado_escalar_u.resultado = arg1 / arg2;

	return &result;
}

resultado_vectorial *
sumavec_1_svc(vecx arg1, vecx arg2,  struct svc_req *rqstp)
{
	#define vec_res result.resultado_vectorial_u.resultado

	static resultado_vectorial  result;
	xdr_free((xdrproc_t) xdr_resultado_vectorial, &result);

	vec_res.vecx_len = min(arg1.vecx_len, arg2.vecx_len);
	vec_res.vecx_val = malloc(sizeof(int[vec_res.vecx_len]));

	for (u_int i = 0; i < vec_res.vecx_len; i++)
		vec_res.vecx_val[i] = arg1.vecx_val[i] + arg2.vecx_val[i];

	return &result;
}

resultado_vectorial *
restavec_1_svc(vecx arg1, vecx arg2,  struct svc_req *rqstp)
{
	#define vec_res result.resultado_vectorial_u.resultado

	static resultado_vectorial  result;
	xdr_free((xdrproc_t) xdr_resultado_vectorial, &result);

	vec_res.vecx_len = min(arg1.vecx_len, arg2.vecx_len);
	vec_res.vecx_val = malloc(sizeof(int[vec_res.vecx_len]));

	for (u_int i = 0; i < vec_res.vecx_len; i++)
		vec_res.vecx_val[i] = arg1.vecx_val[i] - arg2.vecx_val[i];

	return &result;
}

resultado_vectorial *
productovec_1_svc(vecx arg1, vecx arg2,  struct svc_req *rqstp)
{
	#define vec_res result.resultado_vectorial_u.resultado

	static resultado_vectorial  result;
	xdr_free((xdrproc_t) xdr_resultado_vectorial, &result);

	vec_res.vecx_len = min(arg1.vecx_len, arg2.vecx_len);
	vec_res.vecx_val = malloc(sizeof(int[vec_res.vecx_len]));

	for (u_int i = 0; i < vec_res.vecx_len; i++)
		vec_res.vecx_val[i] = arg1.vecx_val[i] * arg2.vecx_val[i];

	return &result;
}

resultado_vectorial *
productovecsc_1_svc(vecx arg1, int arg2,  struct svc_req *rqstp)
{
	#define vec_res result.resultado_vectorial_u.resultado

	static resultado_vectorial  result;
	xdr_free((xdrproc_t) xdr_resultado_vectorial, &result);

	vec_res.vecx_len = arg1.vecx_len;
	vec_res.vecx_val = malloc(sizeof(int[vec_res.vecx_len]));

	for (u_int i = 0; i < vec_res.vecx_len; i++)
		vec_res.vecx_val[i] = arg1.vecx_val[i] * arg2;

	return &result;
}

resultado_matricial *
sumamat_1_svc(matx arg1, matx arg2,  struct svc_req *rqstp)
{
	#define mat_res result.resultado_matricial_u.resultado

	static resultado_matricial  result;
	xdr_free((xdrproc_t) xdr_resultado_matricial, &result);

	mat_res.orden = min(arg1.orden, arg2.orden);
	mat_res.filas = malloc(sizeof(vecx[mat_res.orden]));

	for (u_int i = 0; i < mat_res.orden; i++)
	{
		mat_res.filas[i].vecx_len = mat_res.orden;
		mat_res.filas[i].vecx_val = malloc(sizeof(int[mat_res.orden]));
	}

	for (u_int i = 0; i < mat_res.orden; i++)
		for (u_int j = 0; j < mat_res.orden; j++)
			mat_res.filas[i].vecx_val[j] =
				arg1.filas[i].vecx_val[j] +
				arg2.filas[i].vecx_val[j];

	return &result;
}

resultado_matricial *
restamat_1_svc(matx arg1, matx arg2,  struct svc_req *rqstp)
{
	#define mat_res result.resultado_matricial_u.resultado

	static resultado_matricial  result;
	xdr_free((xdrproc_t) xdr_resultado_matricial, &result);

	mat_res.orden = min(arg1.orden, arg2.orden);
	mat_res.filas = malloc(sizeof(vecx[mat_res.orden]));

	for (u_int i = 0; i < mat_res.orden; i++)
	{
		mat_res.filas[i].vecx_len = mat_res.orden;
		mat_res.filas[i].vecx_val = malloc(sizeof(int[mat_res.orden]));
	}

	for (u_int i = 0; i < mat_res.orden; i++)
		for (u_int j = 0; j < mat_res.orden; j++)
			mat_res.filas[i].vecx_val[j] =
				arg1.filas[i].vecx_val[j] -
				arg2.filas[i].vecx_val[j];

	return &result;
}

resultado_matricial *
productomat_1_svc(matx arg1, matx arg2,  struct svc_req *rqstp)
{
	#define mat_res result.resultado_matricial_u.resultado

	static resultado_matricial  result;
	xdr_free((xdrproc_t) xdr_resultado_matricial, &result);

	mat_res.orden = min(arg1.orden, arg2.orden);
	mat_res.filas = malloc(sizeof(vecx[mat_res.orden]));

	for (u_int i = 0; i < mat_res.orden; i++)
	{
		mat_res.filas[i].vecx_len = mat_res.orden;
		mat_res.filas[i].vecx_val = malloc(sizeof(int[mat_res.orden]));
	}

	for (u_int i = 0; i < mat_res.orden; i++)
		for (u_int j = 0; j < mat_res.orden; j++)
			mat_res.filas[i].vecx_val[j] =
				arg1.filas[i].vecx_val[j] *
				arg2.filas[i].vecx_val[j];

	return &result;
}

resultado_matricial *
productomatsc_1_svc(matx arg1, int arg2,  struct svc_req *rqstp)
{
	#define mat_res result.resultado_matricial_u.resultado

	static resultado_matricial  result;
	xdr_free((xdrproc_t) xdr_resultado_matricial, &result);

	mat_res.orden = arg1.orden;
	mat_res.filas = malloc(sizeof(vecx[mat_res.orden]));

	for (u_int i = 0; i < mat_res.orden; i++)
	{
		mat_res.filas[i].vecx_len = mat_res.orden;
		mat_res.filas[i].vecx_val = malloc(sizeof(int[mat_res.orden]));
	}

	for (u_int i = 0; i < mat_res.orden; i++)
		for (u_int j = 0; j < mat_res.orden; j++)
			mat_res.filas[i].vecx_val[j] = arg1.filas[i].vecx_val[j] * arg2;

	return &result;
}
